Title: World map generation
Slug: world-map-generation
Date: 2020-06-24 11:40:00
Tags: map, world, procedural generation
Category: map
Authors: Aleksander ChrabÄ…szcz
Summary: World map generation for Exeris

In the recent months of lockdown I've worked a bit on reviving Exeris game and one of the most important issues left to do was procedural world generation. I wanted to be able to create islands and archipelagos which would become a game world on the beta game server.

# Procedural world generation

My work is based on another article hosted on Stanford website, and it's not just an inspiration, but rather re-implementation of almost the same algorithm in Python. So this article explains how to do some things similarly, but usually better, because of more time spent and lack of some limitations which I had to impose.

#### Link to the article: [http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/](http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/).  

<br>
I didn't decide to just use it,s because of some special game requirements, some limitations to make terra-exeris - map drawing library - work and the fact I've preferred to have it in Python for further processing.

My world map generator tries to perform the task as simply as possible, so I'm not trying to introduce the concepts of tectonics, climates, movements of pressure areas. Things that can give good results when generated randomly are generated using random number generator or noise functions.

The world generation consists of multiple steps run one after another. I'm going to explain them below.

# Naming conventions

The whole world map is split into polygons which are generated using Voronoi algorithm, to make them random, but have similar area and features.

- Region - a polygon generated by Voronoi algorithm, the name most commonly used in the code
- Vertex - a place where more than two polygons meet. Each region is represented as an (ordered) list of vertices 
- Neighbour of vertex B - a vertex that touches edge which is also touched by vertex B 
- Neighbour of region B - a region touches an edge common with region B


# 1. Generation of polygons using Voronoi with Lloyd's relaxation

[It's well explained here](http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/#polygons), so I won't write much about it.

The result of my version is visible below. I didn't write it myself, but I've used a function from SciPy.

![Voronoi diagram of the world map](/images/world-map-generation/voronoi.png)

Because this is one of the slowest steps and the difference between the Voronoi diagrams is not that important, I am caching the result of Voronoi generation to save time.

# 2. Heightmap generation

This one is significantly different from the linked article. Because of how the resources should be distributed and that I need long distinct mountain chains, I've decided to start generating islands by randomly creating mountain chains of given (random) height and then recursively decrease this height in neigbhours based on value of Perlin noise at the specific point. This gives randomness.

TODO Explain that mountain chains can be slightly broken.

![Heightmap](/images/world-map-generation/heightmap.png)

# 3. River generation

Very easy, I select a random vertex high enough to be a mountain and start going downslope. 

For each vertex in the map I've created a list of downslope vertices, which are neighbours with height lower than this vertex.

![Downslopes for each vertex](/images/world-map-generation/downslopes.png)

To generate another segment of the river, I select a random downslope location.

A small heuristic improvement is when there's no downslope location, then the last segment of the river is removed and the downslope location is generated again. This algorithm can try to "go back" multiple steps before giving up. It's to decrease chance of being trapped into "wrong path". If the river still cannot reach the coast of a lake or sea, then a new lake is generated.

![Voronoi diagram of the world map](/images/world-map-generation/rivers.png)

The final result is visible above

# Terrain generation

It's based on moisture (distance to any river or lake) and height (which was generated in step 2). I assume the island/archipelago is small enough to have the same climate everywhere.

The following terrain types can be assigned:
lake, deep_water, shallow_water, mountain, coniferous forest, deciduous forest, grassland, plains

![Terrain](/images/world-map-generation/terrain.png)

# Removing artifacts before clustering

Because my code is not perfect and it's easier to impose some invariants afterwards. Also some additional rules can be imposed there, after the main part of the code is done.

The following functions are performed:

 - add_shallow_water_near_coast - it's to make sure there's not a single deep water region next to the land. It's to make it always possible for small ships (which can sail only on shallow water) to sail around the island and prevent big ships from sailing to close to land
 - shallowize_isolated_deep_water - areas of deep water which don't touch the world map border are isolated so they should form a gulf of shallow water
 - shallowize_lakes_touching_sea - if lake is generated next to the sea, then all the water in it becomes salted, so it becomes a sea gulf
 - deforest_near_coast - forest locations being directly near the coast could give too much advantage, because of importance of shipbuilding industry. One of ideas of the game is to require having both settlements on the coast and inland and make them trade
 - remove_river_segments_in_lakes - sometimes a lake is generated on area where there's already a river. Or other bad thing happens, which looks silly
 - remove_mountain_chains_which_are_too_low - mountain chain can be generated with the height lower than required by the mountain terrain. It affects the height of the area around it, but it's shouldn't be treated as a mountain chain in terms of generating graphics for mountain peaks by terra-exeris
 - remove_small_isolated_terrain_areas - when some terrain area consists of less than X regions then it should be removed and turned into the most frequent neighbour

# Clustering

Merges all regions of the same terrain type being next to each another to create big clusters/blobs of the same terrain type. It's represented by a polygon* which can potentially take a large area of the map.

* polygon - in GIS nomenclature polygon consists of external ring and internal rings, which means a polygon can have holes in itself

# Removing arfifacts after clustering

Here is only one technical thing to improve:
 - fix_mountain_center_line_to_fully_cover_mountain_polygon - mountain center is a line generated in step 2, so it's done before assigning terrain types. Terra-exeris requires that terrain of type mountain must be an area split into two by the mountain center line. A mountain can become a bit longer than planned earlier, so also a center line must be lengthened.

![Terrain](/images/world-map-generation/final.png)

The final result looks like that

# Resource generation

It's the part I'm still working on. It's a hard task, because, unlike physical map generation, this is not a very popular subject so I need to invent my own solution. I'll describe it in the next post.

# Plotting/Exporting to GIS

For testing purposes a simplified graphical representation is created. To be able to use the map in the game, both for generating a nicer map image by terra-exeris and to be able to process it in the game (e.g. for checking where the person can move) it must be exported to a format known by Exeris to import it to the game's database.

